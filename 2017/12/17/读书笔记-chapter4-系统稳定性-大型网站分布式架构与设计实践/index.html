<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />



  <link rel="icon" type="image/png" sizes="32x32" href="https://sfault-avatar.b0.upaiyun.com/206/579/2065794108-5721d3ee75b36_huge256?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="https://sfault-avatar.b0.upaiyun.com/206/579/2065794108-5721d3ee75b36_huge256?v=5.1.3">






  <meta name="keywords" content="MicroService,msa,架构,soa," />





  <link rel="alternate" href="/atom.xml" title="倚楼听风雨" type="application/atom+xml" />






<meta name="description" content="主要内容:常用的日志分析命令，如cat,grep,wc,less,sed,awk等如何进行集群的监控，包括监控指标的定义、心跳检测、容量评估等如何保障高并发系统的稳定运行，如采用流量控制、依赖管理、服务分级、开关等策略。如何优化应用的性能，包括前端优化、Java程序优化、数据库查询优化等如何进行Java应用故障的在线排查，包括一系列排查工具的使用，及案例。    “You can’t contro">
<meta name="keywords" content="MicroService,msa,架构,soa">
<meta property="og:type" content="article">
<meta property="og:title" content="[读书笔记]chapter4-系统稳定性-大型网站分布式架构与设计实践">
<meta property="og:url" content="http://xbynet.top/2017/12/17/读书笔记-chapter4-系统稳定性-大型网站分布式架构与设计实践/index.html">
<meta property="og:site_name" content="倚楼听风雨">
<meta property="og:description" content="主要内容:常用的日志分析命令，如cat,grep,wc,less,sed,awk等如何进行集群的监控，包括监控指标的定义、心跳检测、容量评估等如何保障高并发系统的稳定运行，如采用流量控制、依赖管理、服务分级、开关等策略。如何优化应用的性能，包括前端优化、Java程序优化、数据库查询优化等如何进行Java应用故障的在线排查，包括一系列排查工具的使用，及案例。    “You can’t contro">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://xbynet.top/data/upload/2a31f4f8-de13-11e7-99e4-d46a6ad5b910.png">
<meta property="og:updated_time" content="2017-12-21T01:23:33.655Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[读书笔记]chapter4-系统稳定性-大型网站分布式架构与设计实践">
<meta name="twitter:description" content="主要内容:常用的日志分析命令，如cat,grep,wc,less,sed,awk等如何进行集群的监控，包括监控指标的定义、心跳检测、容量评估等如何保障高并发系统的稳定运行，如采用流量控制、依赖管理、服务分级、开关等策略。如何优化应用的性能，包括前端优化、Java程序优化、数据库查询优化等如何进行Java应用故障的在线排查，包括一系列排查工具的使用，及案例。    “You can’t contro">
<meta name="twitter:image" content="http://xbynet.top/data/upload/2a31f4f8-de13-11e7-99e4-d46a6ad5b910.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://xbynet.top/2017/12/17/读书笔记-chapter4-系统稳定性-大型网站分布式架构与设计实践/"/>





  <title>[读书笔记]chapter4-系统稳定性-大型网站分布式架构与设计实践 | 倚楼听风雨</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?9f9e6e9198259e7a598474c9df6397dc";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">倚楼听风雨</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">淡看江湖路</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-相册">
          <a href="/photos/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            相册
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>

<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xbynet.top/2017/12/17/读书笔记-chapter4-系统稳定性-大型网站分布式架构与设计实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xbynet">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://sfault-avatar.b0.upaiyun.com/206/579/2065794108-5721d3ee75b36_huge256">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="倚楼听风雨">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">[读书笔记]chapter4-系统稳定性-大型网站分布式架构与设计实践</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-17T13:17:13+08:00">
                2017-12-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/大型网站分布式架构与设计实践/" itemprop="url" rel="index">
                    <span itemprop="name">大型网站分布式架构与设计实践</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/12/17/读书笔记-chapter4-系统稳定性-大型网站分布式架构与设计实践/" class="leancloud_visitors" data-flag-title="[读书笔记]chapter4-系统稳定性-大型网站分布式架构与设计实践">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">热度&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  15,044
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  58
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <script src="\assets\js\APlayer.min.js"> </script><p>主要内容:<br>常用的日志分析命令，如cat,grep,wc,less,sed,awk等<br>如何进行集群的监控，包括监控指标的定义、心跳检测、容量评估等<br>如何保障高并发系统的稳定运行，如采用流量控制、依赖管理、服务分级、开关等策略。<br>如何优化应用的性能，包括前端优化、Java程序优化、数据库查询优化等<br>如何进行Java应用故障的在线排查，包括一系列排查工具的使用，及案例。   </p>
<p>“You can’t control what you can’t measure”<br>“Should you measure something be sure what you really measure otherwise the results can keep you far from reality. Always validate your assumptions and RTFM”<br>“Don’t assumptions base on lack of understanding of used terminology or it’s ambiguity can be accounted for it”   </p>
<a id="more"></a>
<h2 id="在线日志分析"><a href="#在线日志分析" class="headerlink" title="在线日志分析"></a>在线日志分析</h2><p>日志包含信息：异常堆栈信息，访问ip，请求url，应用响应时间，内存垃圾回收信息，及程序日志信息。通过对异常堆栈信息分析定位程序bug；对访问ip及url，参数的分析排查是否遭到攻击，及攻击的形式；通过应用的响应时间、垃圾回收及系统load来判断系统负载；通过线程dump，判断是否死锁及现场阻塞的原因；通过应用的GC(Garbage Collection)日志，对系统代码和JVM内存参数今夕优化，减少GC次数与stop the world时间，优化响应时间。</p>
<p>1、<strong>日志分析常用命令</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat 查看文件内容， -n 显示行号；分页查看的有:more/less; head/tail 显示文件头/尾多少行， -n指定行数， 对于tail -f可以实时持续显示最新的行。    </span><br><span class="line">sort:对列进行排序，默认按字符排序，-n指定按数字，-r逆序，-k指定列(从1开始)，-t指定列间分隔符(默认空格)   </span><br><span class="line">wc:字符统计，-l 行数，-c字节数，-L最长行的长度 ，-w单词数  </span><br><span class="line">uniq:连续行去重,通常与sort联合使用。-c 显示重复次数，-u只显示不重复的，-d只显示重复的行  </span><br><span class="line">grep:字符串查找，-c显示行数, grep支持正则表达式。   </span><br><span class="line">find:文件查找 find path -name [filename|print]    </span><br><span class="line">whereis:定位可执行文件的位置  </span><br><span class="line">expr:表达式求值，*需要转义   </span><br><span class="line">tar:归档文件   </span><br><span class="line">curl:URL访问工具  </span><br><span class="line">cut:过滤指定列，-f指定列号，-d指定列分隔符</span><br></pre></td></tr></table></figure></p>
<p>例子:nginx为例，查看请求的访问量，访问量排名前10的ip地址。这样可以定位是否存在HTTP flood攻击(也称CC攻击).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | cut -f1 -d &quot; &quot; | sort | uniq -c | sort -k 1 -n -r |head -10</span><br></pre></td></tr></table></figure></p>
<p>例子:页面访问量排名前10的url<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | cut -f4 -d &quot; &quot; | sort | uniq -c | sort -k 1 -n -r |head -10</span><br></pre></td></tr></table></figure></p>
<p>例子:查看最耗时页面(响应时间最长的url)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | sort -k 2 -n -r |head -10</span><br></pre></td></tr></table></figure></p>
<p>例子:统计404请求的占比(404请求过多，要么就是有恶意攻击者在进行扫描，要么就是系统出问题了，500也是如此。)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export total_line=`wc -l access.log | cut -f1 -d &quot; &quot;` &amp;&amp; export not_found_line=`awk &apos;$6==&apos;404&apos;&#123;print $6&#125;&apos; access.log|wc -l` &amp;&amp; expr $not_found_line \* 100 / $total_line</span><br></pre></td></tr></table></figure></p>
<p>2、<strong>日志分析脚本</strong><br>sed：流编辑器，一行一行读取，面向行，不会修改文件本身。 set [options] ‘command’ files   </p>
<p>将日志中的xxx替换成yahoo输出: sed ‘s/xxx/yahoo/‘ access.log | head -10<br>筛选日志中指定的行输出: sed -n ‘2,6p’ access.log<br>根据正则表达式删除日志中指定的行 sed ‘/qq/d’ access.log<br>支持将command写到文件里再加载执行: sed [options] -f scriptfile files  </p>
<p>awk:提供一个类似于编程的开放环境，可以自定义文本处理规则，修改和重新组织文件中的内容。awk [option] ‘pattern {action}’ file<br>awk ‘/google/{print $5,$6}’ access.log | head -10<br>awk ‘length($0)&gt;40{print $3}’ access.log | head -10    $0表示当前行<br>awk ‘{line = sprintf(“method:%s,response:%s”,$3,$7);print line}’ access.log | head -10<br>支持将command写到文件里再加载执行: awk [options] -f scriptfile files   </p>
<h2 id="集群监控"><a href="#集群监控" class="headerlink" title="集群监控"></a>集群监控</h2><p>1、<strong>监控指标</strong><br>系统运行的繁忙程度、健康状态，反映在一系列的运行期指标上。理论基础：<strong>木桶原理</strong>。指标如CPU负载，磁盘IO，内存占用，FullGC，请求QPS过高，网络繁忙，丢包率等。</p>
<p><strong>load:</strong></p>
<p>load即特定时间间隔内运行队列中的平均线程数。如果一个线程没有处于IO等待、等待wait、终止等状态时，那么该线程就会处于运行队列中。每个CPU的核都维护了一个运行队列，系统的load主要由运行队列来决定。load值越大说明系统CPU越繁忙。一般来说，只要每个CPU当前的活动现场数不大于3，其负载就可以认为是正常的，如果大于5，则表示负载挺高了，需要采取措施来降低系统负载。<br>top和uptime可以查看系统的load值。<br>执行uptime将会显示出系统的当前时间、上线时间、当前的用户数量以及过去<code>1、5、15分钟</code>内的系统负载。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uptime</span><br><span class="line">10:52 PM up 1337 days, 7:45, 3 users, load averages: 0.21, 0.24, 0.23</span><br></pre></td></tr></table></figure></p>
<p><strong>CPU利用率：</strong></p>
<p>CPU消耗主要在这几个方面:用户进程，内核进程，中断处理，I/O等待，Nice时间(优先级处理)，丢失时间，空闲等。CPU利用率就是这些时间所占总时间的百分比。<br>top命令查看:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">top | grep Cpu    </span><br><span class="line">us — 用户空间占用CPU的百分比。</span><br><span class="line">sy — 内核空间占用CPU的百分比。</span><br><span class="line">ni — 改变过优先级的进程占用CPU的百分比</span><br><span class="line">id — 空闲CPU百分比</span><br><span class="line">wa — IO等待占用CPU的百分比</span><br><span class="line">hi — 硬中断（Hardware IRQ）占用CPU的百分比</span><br><span class="line">si — 软中断（Software Interrupts）占用CPU的百分比  </span><br><span class="line">st — 丢失时间(Steal Time),是在硬件虚拟化开始流行后新增的，表示被强制等待虚拟CPU的时间，此时hypervisor正在为另一个虚拟处理器服务。如果st占比较高，则表示当前虚拟机与宿主上的其他虚拟机间的CPU争用较为频繁。</span><br></pre></td></tr></table></figure></p>
<ol>
<li>若 %iowait 的值过高，表示硬盘存在I/O瓶颈  </li>
<li>若 %idle 的值高但系统响应慢时，有可能是 CPU 等待分配内存，此时应加大内存容量  </li>
<li>若 %idle 的值持续低于 10，则系统的 CPU 处理能力相对较低，表明系统中最需要解决的资源是 CPU。  </li>
</ol>
<p>对于多U多核CPU监控，在top基本视图中，按键盘数字“1”，可监控每个逻辑CPU的状况。如果按Shift+H键，则可以按线程来查看CPU消耗情况。这一点对java应用来说很有用。    </p>
<p>Linux查看物理CPU个数、核数、逻辑CPU个数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 总核数 = 物理CPU个数 X 每颗物理CPU的核数</span><br><span class="line"># 总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数</span><br><span class="line"></span><br><span class="line"># 查看物理CPU个数</span><br><span class="line">cat /proc/cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l</span><br><span class="line"># 查看每个物理CPU中core的个数(即核数)</span><br><span class="line">cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uniq</span><br><span class="line"># 查看逻辑CPU的个数</span><br><span class="line">cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l</span><br></pre></td></tr></table></figure></p>
<p><strong>磁盘剩余空间:   </strong><br>df -h 查看磁盘剩余空间<br>du 查看目录和文件的大小，如du -d 1 -h /home/xby , -d指定递归深度</p>
<p><strong>网络traffic:  </strong><br>对于进行负载均衡和反向代理的节点，或作为集群master的节点，对网卡和带宽的要求更高。在某些突发大流量情况下有可能会成为瓶颈。因此关注网络的流量，清楚各节点的阀值和水位也很重要。<br>sar -n DEV 1 1 查看系统网络状态。-n 汇报网络状态，DEV表示查看各个网卡的流量，1表示抽样间隔为1秒1次，后面的1表示抽样总次数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IFACE：就是网络设备的名称；</span><br><span class="line">rxpck/s：每秒钟接收到的包数目</span><br><span class="line">txpck/s：每秒钟发送出去的包数目</span><br><span class="line">rxbyt/s：每秒钟接收到的字节数</span><br><span class="line">txbyt/s：每秒钟发送出去的字节数</span><br><span class="line">rxcmp/s：每秒钟接收到的压缩包数目</span><br><span class="line">txcmp/s：每秒钟发送出去的压缩包数目</span><br><span class="line">txmcst/s：每秒钟接收到的多播包的包数目</span><br></pre></td></tr></table></figure>
<p>如果你使用SOCK关键字，则会针对socket连接进行汇报，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sar -n SOCK 1 3</span><br><span class="line">tcpsck：当前正在被使用于TCP的socket数目</span><br><span class="line">udpsck：当前正在被使用于UDP的socket数目</span><br><span class="line">rawsck：当前正在被使用于RAW的socket数目</span><br><span class="line">ip-frag：当前的IP分片的数目</span><br><span class="line">如果你使用FULL关键字，相当于DEV、EDEV和SOCK三者的综合。</span><br></pre></td></tr></table></figure></p>
<p>让sar在某个特定时间结束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sar 1 0 -e 15:00:00 &gt; data.txt   </span><br><span class="line">//每隔1秒记录CPU的使用情况，直到15点，数据将保存到data.txt文件中。(-e 参数表示结束时间，注意时间格式：必须为hh:mm:ss格式)</span><br></pre></td></tr></table></figure></p>
<p><strong>磁盘I/O </strong><br>iostat -d -k 查看系统的I/O状况，-d表示查看磁盘使用情况 -k表示kb单位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tps：该设备每秒的传输次数（transfers per second）。</span><br><span class="line">kB_read/s：每秒从设备（drive expressed）读取的数据量；</span><br><span class="line">kB_wrtn/s：每秒向设备（drive expressed）写入的数据量；</span><br><span class="line">kB_read：读取的总数据量；</span><br><span class="line">kB_wrtn：写入的总数量数据量；这些单位都为Kilobytes。  </span><br><span class="line">await表示平均每次设备I/O操作的等待时间（以毫秒为单位）。 </span><br><span class="line">svctm表示平均每次设备I/O操作的服务时间（以毫秒为单位）。</span><br><span class="line">%util表示一秒中有百分之几的时间用于I/O操作。</span><br></pre></td></tr></table></figure></p>
<p>对以磁盘IO性能，一般有如下评判标准：<br>正常情况下svctm应该是小于await值的，而svctm的大小和磁盘性能有关，CPU、内存的负荷也会对svctm值造成影响，过多的请求也会间接的导致svctm值的增加。<br>await值的大小一般取决与svctm的值和I/O队列长度以及I/O请求模式，如果svctm的值与await很接近，表示几乎没有I/O等待，磁盘性能很好，如果await的值远高于svctm的值，则表示I/O队列等待太长，系统上运行的应用程序将变慢，此时可以通过更换更快的硬盘来解决问题。<br>%util项的值也是衡量磁盘I/O的一个重要指标，如果%util接近100%，表示磁盘产生的I/O请求太多，I/O系统已经满负荷的在工作，该磁盘可能存在瓶颈。长期下去，势必影响系统的性能，可以通过优化程序或者通过更换更高、更快的磁盘来解决此问题。   </p>
<p><strong>内存使用:</strong><br>free -m   可用内存=free+buffers+cached<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@nonamelinux ~]# free</span><br><span class="line">       total           used       free     shared    buffers     cached</span><br><span class="line">Mem:    386024      377116     8908       0           21280     155468</span><br><span class="line">-/+ buffers/cache:     200368    185656</span><br><span class="line">Swap:    393552            0          393552</span><br><span class="line">第二行(mem)：</span><br><span class="line">total:总计物理内存的大小。</span><br><span class="line">used:已使用多大。</span><br><span class="line">free:可用有多少。</span><br><span class="line">Shared:多个进程共享的内存总额。</span><br><span class="line">Buffers/cached:缓存的大小。</span><br><span class="line">第三行(-/+ buffers/cached):</span><br><span class="line">used:已使用多大。</span><br><span class="line">free:可用有多少。</span><br><span class="line">第二行(mem)的used/free与第三行(-/+ buffers/cache) used/free的区别。</span><br><span class="line">这两个的区别在于使用的角度来看，第一行是从OS的角度来看，因为对于OS，buffers/cached 都是属于被使用，所以他的可用内存是8908KB,已用内存是377116KB,其中包括，内核（OS）使用+Application(X,oracle,etc)使用的+buffers+cached.</span><br><span class="line">第三行所指的是从应用程序角度来看，对于应用程序来说，buffers/cached 是等于可用的，因为buffer/cached是为了提高文件读取的性能，当应用程序需在用到内存的时候，buffer/cached会很快地被回收。</span><br><span class="line">所以从应用程序的角度来说，可用内存=free+buffers+cached</span><br></pre></td></tr></table></figure></p>
<p>使用<code>vmstat</code>查看swap I/O的情况,确保swap I/O较低。否则会严重影响系统性能。   </p>
<p><strong>QPS-query per second. 每秒的查询数：  </strong><br>qps在很大程度上代表了系统在业务上的繁忙程度，而每次请求的背后，可能对应着多次磁盘io，多次网络请求，以及多个cpu时间片。通过关注qps是否超过阀值，来决定是否进行扩容，以避免压力过大而宕机。   </p>
<p><strong>RT-response time 响应时间:  </strong><br>rt是一个非常关键的指标，直接关系到前端用户的体验。因此需要尽可能降低rt。例如，通过CDN缩短用户请求的物理路径，通过内容压缩来减少传输的字节数，使用缓存来减少磁盘io和网络请求等。而通过nginx的access log ，便可以得知每个请求的响应时间。不过需要在访问日志的输出格式中加上$request_time变量。  </p>
<p><strong>数据库相关指标select/ps,update/ps,delete/ps</strong>.   措施:增加读库，分库分表等。  </p>
<p><strong>GC:</strong><br>对于Java应用而言，不得不关注GC。GC又分为Minor GC与Full GC.<br>在JVM内存分代回收的情况下，对象在JVM内存的新生代Eden区中分配。当Eden区没有足够的空间时虚拟机将发起一次MinorGC，该GC发生在新生代，而且也会比较频繁，回收速度也很快。而Major GC,也称Full GC,是发生在年老代的，速度比MinorGC慢得多，因此导致应用停顿时间(stop the world)也就更长。可以对JVM的一些内存参数进行调整和优化，以降低GC时应用停止响应的时间。如果一个应用频繁进行Full GC，那么它的性能肯定是有问题的。这时候就需要我们实时获取GC情况。  </p>
<p><strong>2、心跳检测</strong><br>对于集群服务器和部署于其上的应用的心跳检测是必不可少的，因为这可以帮助我们及时感知问题。<br>对于自治的分布式系统而言，一般都有一整套的集群心跳检测机制，能够实时地移除掉宕机的Slave，避免路由规则再次分配到它。如果是Master宕机，集群也能够自动进行Master选举。如Zookeeper.也有一部分系统如MySQL,Nginx，可以通过外部干预，使备份机器stand by，或是双机互为备份，以实现故障切换，避免单点故障。<br>ping 是最常用的心跳检测方法。 -c 指定执行次数<br>应用层检测：<br>虽然ping可以检测网络是否畅通，但是对于应用层而言，即使网络畅通，也有可能出现问题，如频繁FullGC导致应用不能响应等。应用可以开放一个自检接口，我们可以通过脚本curl去请求自检接口，来达到心跳检测的目的。 curl -s选项为静默模式。</p>
<p><strong>3、容量评估和应用水位 </strong><br>新系统上线之前或者已上线运行的系统上需要做一些推广活动时，相关的业务方需要对系统的访问量进行评估。业务方给出PV,UV预估，然后我们再逐一细化，推导出落到每一个独立的系统，接口上的流量大概是多少，这样一来，每个子系统所承载的量也就清晰了。然后再评估机器的数量，网络的带宽和技术实现方式。<br>压力测试最关系的是qps和rt两个指标<br>在进行系统峰值评估时，一般会遵循80/20原则。<br>我们也可以通过水位图来了解系统的压力。当前水位=当前总qps/(单台机器极限qpsx机器数)x100%   </p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>为了防止某些热点事件或者推广活动导致的访问量激增的情况，需要做好流量控制，在流量到来之前，指定相应的应急预案，以避免系统被激增的流量压垮。<br>流量控制可以从多个维度来进行，如系统的总并发请求数限制，或者限制单位时间内的请求次数(如限制qps)，或者通过白名单机制来限制每一个接入系统调用的频率等。<br>流控实现，最简单的是基于java的信号量Semaphore,更高级点的是采用漏桶或令牌桶算法，guava中有个RetaLimiter实现了令牌桶算法。<br>还有种方式，就是将消息异步化，扔到消息队列后不管，直接返回响应给用户。如基于ActiveMQ,不过需要考虑消息积压，事务消息，重复投递去重等问题。   </p>
<p><strong>服务稳定性：</strong><br>分布式SOA环境下系统的依赖错综复杂。如何控制由于第三方服务不稳定而形成的多米诺骨牌效应。<br>1、依赖管理：分布式系统由于高度解耦，最终形成一个网状的依赖关系。对于服务提供者而言，它必须轻蹙，谁调用了自己，调用的频次怎样，这样才能知道当前系统的压力和水位在一个怎样的层次上，是否需要进行扩容。同时，服务提供者也需要对自己依赖的服务了然于胸，哪些是核心链路所依赖的服务，哪些是非核心链路的依赖，以便依赖的系统出现问题时，及时进行<code>服务降级</code>,避免因非核心依赖导致的故障传导，影响当前系统的稳定性。<br><strong>分布式依赖管理的依据：通过调用日志的收集和整理，将其中的调用关系，频次统计分析出来.</strong>   </p>
<p>2、<strong>优雅降级</strong><br>通过依赖管理，我们知道了服务间的调用关系。接下来，我们便可以根据当前系统所依赖的服务及系统流程，来判断依赖的服务是否会影响应用的主流程，以此来决定当前应用依赖的优先级。<br>当依赖的服务出现不稳定，响应缓慢或者掉调用超时，宕机等时，当前系统需要能够及时感知并进行相应处理，否则大量超时的调用，有可能将当前系统的线程和可用连接数用完，导致新的请求进不来，服务僵死，这便是故障传递。最终形成多米诺骨牌效应。使得整个集群都不能对外提供服务。<br>这时服务调用优雅降级的重要性便体现出来了。对于调用超时的非核心服务，可以设定一个阀值，如果调用超时的次数超过这个阀值，便自动将该服务降级。此时跳过对该服务的调用，并指定一个休眠的时间点进行重试。   </p>
<p>3、<strong>服务分级</strong><br>服务提供者需要对服务消费者的优先级进行区分，哪些调用将影响核心链路，哪些调用是非核心链路，当系统压力过大时，必须确保等级高的应用、核心的调用链路优先畅通，而其他的可以暂时”丢车保帅”。  </p>
<p>4、<strong>开关</strong><br>系统需要预先定义一些开关来控制程序的服务提供策略。    </p>
<p>5、<strong>应急方案</strong><br>应急方案需要明确地规定服务的级别，梳理清楚核心应用的调用链路，对于每一种故障，都做出合理的假设，并且要有针对性的处理方法。对于级别低的调用和功能，事先应准备好屏蔽的开关和接口。服务的级别决定哪些调用者是”车”，哪些调用者是”帅”，必要时候要丢车保帅。备用扩容，开关，验证码，流控，负载均衡策略动态修改，多机房部署，异地容灾等</p>
<h3 id="高并发系统设计"><a href="#高并发系统设计" class="headerlink" title="高并发系统设计"></a>高并发系统设计</h3><p>高并发系统设计与普通系统设计的区别在于，既要保障系统的可用性和可扩展性，又要兼顾数据的一致性。还要处理多线程同步的问题。任何细微问题，都有可能在高并发环境下被无限放大，直至系统宕机。</p>
<p>1、<strong>操作原子性</strong>：线程锁，<strong>CAS</strong>(CompareAndSet) Atomic类,数据库事务操作(ACID,Atomic,Consistency,Isolation,Durability)<br>2、<strong>数据一致性</strong>:<br>分布式系统常常通过复制数据来提高系统的可靠性和容错性，并且将数据的副本放到不同的机器上。由于多个副本的存在，使得维护副本一致性的代价很高。因此许多分布式系统都采用弱一致性或者是最终一致性，来提高系统的性能和吞吐能力，所以出现了不同的一致性模型和算法。   </p>
<ul>
<li>强一致性要求无论数据的更新操作是在哪个副本上执行，之后所有的读操作都要能够获取到更新的最新数据。这种情况下需要通过分布式事务来保证操作的原子性，并且外界无法读到系统的中间状态。   </li>
<li>弱一致性指的是系统的某个数据被更新后，后续对该数据的读取操作取到的可能是更新前的值，也可能是更新后的值。全部用户完全读取到更新后的数据需要经过一段时间，这段时间称为”不一致性窗口”。   </li>
<li>最终一致性是弱一致性的特殊形式，与弱一致性的区别就是”不一致性窗口”的时间依赖于网络的延迟、系统的负载、副本的个数。   </li>
</ul>
<p>分布式系统采用最终一致性的例子很多，如MySQL的主从数据同步，ZooKeeper的Leader election和Atomic broadcast等。   </p>
<p>3、<strong>系统可扩展性/可伸缩性  </strong><br>是一种对软件系统计算处理能力的评价指标。高可扩展性意味着系统只要经过很少的改动，甚至只需要添加硬件设备，便能够实现整个系统处理能力的线性增长。由于单台机器硬件受制于科技发展水平和成本，因此，可扩展性更加侧重于系统的水平扩展。设计好的系统可以限制扩展。<br>系统的可扩展性也会受到一些因素的制约，<code>CAP理论</code>(Consistency,Availability,Tolerance of network Partition)指出，系统的一致性、可用性和可扩展性这三个要素对于分布式系统来说，很难同时满足。因此在设计过程中需要进行一些取舍。某些情况下可以放宽对于一致性的严格要求，以使得系统更易于扩展，可靠性更高。   </p>
<p>4、例子：并发减库存<br>采用图像验证码防止机器请求(现在图像识别，打码平台的出现，对验证码的要求更高了，不然很容易被绕过)<br>对于高并发访问的浏览型系统来说，单机数据库如不进行扩展，往往很难支撑。因此常常会采用分库技术来提高数据库的并发能力，并通过分布式缓存技术，降低磁盘io及数据库压力，加快后端的响应速度，qps也就越高。<br>使用分库和缓存技术，吞吐量的确是上去了，但是却带来了跨数据库或者是分布式缓存与数据库之间难以进行事务操作。(分布式事务实现所需付出的性能代价太高)<br>为了避免数据不一致的情况发生，可采用实际库存和浏览库存分离的方式。浏览库存取缓存数据。<br>MySQL的myisam对写操作采用表锁，innodb则是行锁。但即便是行锁缩小了粒度，仍然在高并发修改某一行的情况下可能会出现性能瓶颈，此时我们需要拆行，将原本一行的存储，放在多行上，路由策略可以采用用户id取模等方式。   </p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="如何找到性能瓶颈"><a href="#如何找到性能瓶颈" class="headerlink" title="如何找到性能瓶颈"></a>如何找到性能瓶颈</h3><p>Web的性能优化涉及前端优化、服务端优化、操作系统优化、数据库查询优化、JVM调优等。<br>对于性能优化来说，第一步也是最重要的一步，便是寻找可以优化的点，即性能瓶颈。根据<code>木桶原理</code>，性能瓶颈就是那块最短的木板。   </p>
<p>1、<strong>前端优化工具-YSlow</strong>：网页性能分析<br>2、<strong>页面响应时间</strong>：这个受影响因素会很多，不能作为最终的依据。我们更关注<strong>服务端的RT(response time)时间</strong>。<br>3、<strong>方法响应时间</strong>：定位到响应慢的请求以后，接下来需要深入发掘导致请求响应慢的原因，并且定位到具体的代码。通过对代码的检查分析，能够定位到具体的方法和代码行。不过我们一般借助于<code>btrace</code>——java动态跟踪工具来快速定位和发现耗时的方法。<br>首先，编写一段测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req,HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException,IOException</span>&#123;</span><br><span class="line">    PrintWriter out=resp.getWriter();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">500L</span>);<span class="comment">//通过休眠模拟执行时间较长的方法</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(InterruptException e)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    out.write(<span class="string">"success"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，编写计算方法响应的btrace脚本<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.btrace.annotations.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.sun.btrace.BTraceUtils.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BTrace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodTimeCost</span></span>&#123;</span><br><span class="line">    <span class="meta">@TLS</span> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> starttime;</span><br><span class="line">    <span class="meta">@OnMethod</span>(clazz=<span class="string">"/com\\.http\\.testbtrace\\..*/"</span>,method=<span class="string">"/.+/"</span>,location=<span class="meta">@Location</span>(Kind.ENTRY))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startExecute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        starttime=timeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@OnMethod</span>(clazz=<span class="string">"/com\\.http\\.testbtrace\\..*/"</span>,method=<span class="string">"/.+/"</span>,location=<span class="meta">@Location</span>(Kind.RETURN))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">endExecute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timecost=timeMillis()-starttime;</span><br><span class="line">        <span class="keyword">if</span>(timecost&gt;<span class="number">50</span>)&#123;</span><br><span class="line">            print(strcat(strcat(name(probeClass()),<span class="string">"."</span>),probeMethod()));</span><br><span class="line">            print(<span class="string">" ["</span>);</span><br><span class="line">            print(strcat(<span class="string">"Time taken: "</span>,str(timecost)));</span><br><span class="line">            println(<span class="string">"] "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>启动需要跟踪的java程序，然后执行jps获取该进程的id，最后执行这段btrace脚本。如id为3683。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btrace -cp build 3683 MethodTimeCost.java</span><br></pre></td></tr></table></figure></p>
<p>当然btrace的使用并不局限于此，它的功能十分强大，特别是在Java应用在线故障排查方面，是不可或缺的利器。  </p>
<p>4、<strong>GC日志分析</strong><br>GC日志能够反映出Java应用执行内存回收详细情况，如Minor GC,Full GC的频繁程度、GC所导致应用停止响应的时间，引起GC的原因等。<br>根据程序吞吐量优先还是响应时间优先的不同，sun HotSpot虚拟机1.6版在服务器端提供Parallel Scavenge/Parallel Old与ParNew/CMS两种垃圾收集器组合，其中Parallel Scavenge和ParNew为新生代的垃圾收集器，而Parallel Old和CMS为老年带的垃圾收集器。<br>在JVM启动时加上下面几个参数：<br><code>-verbose:gc -Xloggc:/gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps</code><br>其他GC日志相关参数有-XX:+PrintGC 输出GC日志    -XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息<br>日志示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0.756: [Full GC (System) 0.756: [CMS: 0K-&gt;1696K(204800K), 0.0347096 secs] 11488K-&gt;1696K(252608K), [CMS Perm : 10328K-&gt;10320K(131072K)], 0.0347949 secs] [Times: user=0.06 sys=0.00, real=0.05 secs]  </span><br><span class="line">1.728: [GC 1.728: [ParNew: 38272K-&gt;2323K(47808K), 0.0092276 secs] 39968K-&gt;4019K(252608K), 0.0093169 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]  </span><br><span class="line">2.642: [GC 2.643: [ParNew: 40595K-&gt;3685K(47808K), 0.0075343 secs] 42291K-&gt;5381K(252608K), 0.0075972 secs] [Times: user=0.03 sys=0.00, real=0.02 secs]  </span><br><span class="line">4.349: [GC 4.349: [ParNew: 41957K-&gt;5024K(47808K), 0.0106558 secs] 43653K-&gt;6720K(252608K), 0.0107390 secs] [Times: user=0.03 sys=0.00, real=0.02 secs]  </span><br><span class="line">5.617: [GC 5.617: [ParNew: 43296K-&gt;7006K(47808K), 0.0136826 secs] 44992K-&gt;8702K(252608K), 0.0137904 secs] [Times: user=0.03 sys=0.00, real=0.02 secs]  </span><br><span class="line">7.429: [GC 7.429: [ParNew: 45278K-&gt;6723K(47808K), 0.0251993 secs] 46974K-&gt;10551K(252608K), 0.0252421 secs]</span><br></pre></td></tr></table></figure></p>
<p>我们取倒数第二条记录分析一下各个字段都代表了什么含义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5.617（时间戳）: [ GC（Young GC） 5.617（时间戳）: [ParNew（使用ParNew作为年轻代的垃圾回收期）: 43296K（年轻代垃圾回收前的大小）- &gt;7006K（年轻代垃圾回收以后的大小）(47808K)（年轻代的总大小）, 0.0136826 secs（回收时间）] 44992K（堆区垃圾回收前的大小）-&gt;8702K（堆区垃圾回收后的大小）(252608K)（堆区总大小）, 0.0137904 secs（回收时间）] [ Times: user=0.03（Young GC用户耗时） sys=0.00（Young GC系统耗时）, real=0.02 secs（Young GC实际耗时）]</span><br></pre></td></tr></table></figure></p>
<p>我们再对数据做一个简单的分析<br>从最后一条GC记录中我们可以看到 Young GC回收了 45278-6723=38555K的内存<br>Heap区通过这次回收总共减少了 46974-10551=36423K的内存。<br>38555-36423=2132K说明通过该次Young GC有2132K的内存被移动到了Old Gen，</p>
<p>我们来验证一下<br>在最后一次Young GC的回收以前 Old Gen的大小为8702-7006=1696<br>回收以后Old Gen的内存使用为10551-6723=3828<br>Old Gen在该次Young GC以后内存增加了3828-1696=2132K 与预计的相符   </p>
<p><strong>CMS</strong>(Concurrent Mark-Sweep)是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动JVM参数加上-XX:+UseConcMarkSweepGC (默认HotSpot JVM使用的是并行收集器)，这个参数表示对于老年代的回收采用CMS。CMS采用的基础算法是：标记—清除。<br>整个过程大致分为4步：  </p>
<ol>
<li>初始标记 (CMS initial mark):会STW(Stop The World),为了收集应用程序的对象引用需要暂停应用程序线程,该阶段完成后，应用程序线程再次启动  </li>
<li>并发标记 (CMS concurrent mark):从第一阶段收集到的对象引用开始，遍历所有其他的对象引用    </li>
<li>重新标记 (CMS remark) :会STW,由于对象引用可能会发生进一步改变，因此应用程序线程会再一次被暂停以更新这些变化,并且在进行实际的清理之前确保一个正确的对象引用视图   </li>
<li>并发清理 (CMS concurrent sweep) :所有不再被引用的对象将从堆里清除掉<br>整个过程中，1、3会stw，但是2、4是最耗时的。所以可以减少stw的时间。  </li>
</ol>
<p>注意：<br>一次CMS至少会给Full GC的次数 + 2，因为Full GC的次数是按照老年代GC时stop the world的次数而定的。<br>一般CMS引起的GC时间会很短如ms级，如果达到秒级，那么就需要注意了，很可能是CMS发生了concurrent mode fail之后会退化成Serial Old收集器，它是单线程的标记-压缩收集器，所以耗时会非常的长。查看日志时需要注意是否存在concurrent mode fail       </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2014-12-08T17:24:18.514+0800: 77443.326: [GC [1 CMS-initial-mark: 1382782K(1843200K)] 1978934K(4710400K), 0.0702700 secs] [Times: user=0.07 sys=0.00, real=0.07 secs]</span><br><span class="line">2014-12-08T17:24:18.586+0800: 77443.398: [CMS-concurrent-mark-start]  </span><br><span class="line">2014-12-08T17:24:19.890+0800: 77444.702: [CMS-concurrent-mark: 1.206/1.303 secs] [Times: user=2.80 sys=0.07, real=1.30 secs]   </span><br><span class="line">2014-12-08T17:24:19.890+0800: 77444.702: [CMS-concurrent-preclean-start]  </span><br><span class="line">2014-12-08T17:24:19.906+0800: 77444.718: [CMS-concurrent-preclean: 0.015/0.015 secs] [Times: user=0.02 sys=0.00, real=0.02 secs]   </span><br><span class="line">2014-12-08T17:24:19.906+0800: 77444.718: [CMS-concurrent-abortable-preclean-start]  </span><br><span class="line"> CMS: abort preclean due to time 2014-12-08T17:24:25.181+0800: 77449.993: [CMS-concurrent-abortable-preclean: 5.241/5.275 secs] [Times: user=6.03 sys=0.09, real=5.27 secs]   </span><br><span class="line">2014-12-08T17:24:25.187+0800: 77449.999: [GC[YG occupancy: 749244 K (2867200 K)]77450.000: [Rescan (parallel) , 0.0276780 secs]77450.028: [weak refs processing, 0.2029030 secs]  </span><br><span class="line"> [1 CMS-remark: 1382782K(1843200K)] 2132027K(4710400K), 0.2340660 secs] [Times: user=0.43 sys=0.00, real=0.23 secs</span><br><span class="line">2014-12-08T17:24:25.424+0800: 77450.236: [CMS-concurrent-sweep-start]  </span><br><span class="line">2014-12-08T17:24:27.420+0800: 77452.232: [CMS-concurrent-sweep: 1.918/1.996 secs] [Times: user=2.61 sys=0.05, real=2.00 secs]   </span><br><span class="line">2014-12-08T17:24:27.421+0800: 77452.233: [CMS-concurrent-reset-start]  </span><br><span class="line">2014-12-08T17:24:27.430+0800: 77452.242: [CMS-concurrent-reset: 0.010/0.010 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure>
<p>我们可以看到Full GC的次数应该是2,(因为Full GC的次数是按照老年代GC时stop the world的次数而定的):0.07 secs(initial mark),0.23 secs(remark).<br>可以用<code>jstat -gc</code>得到的时间Full GC的次数和时间。      </p>
<p>最后再次强调一下:</p>
<ol>
<li>Full GC == Major GC指的是对老年代/永久代的stop the world的GC   </li>
<li>Full GC的次数 = 老年代GC时 stop the world的次数   </li>
<li>Full GC的时间 = 老年代GC时 stop the world的总时间   </li>
<li>CMS 不等于Full GC，我们可以看到CMS分为多个阶段，只有stop the world的阶段被计算到了Full GC的次数和时间，而和业务线程并发的GC的次数和时间则不被认为是Full GC   </li>
<li>Full GC本身不会先进行Minor GC，我们可以配置，让Full GC之前先进行一次Minor GC，因为老年代很多对象都会引用到新生代的对象，先进行一次Minor GC可以提高老年代GC的速度。比如老年代使用CMS时，设置CMSScavengeBeforeRemark优化，让CMS remark之前先进行一次Minor GC。    </li>
</ol>
<p>最后要重点注意的是：jstat命令的man-pages说FGC代表的是Full GC事件，而我们通常认为那就是是Full GC的次数。<br>CMS GC参考:<br><a href="https://kamilszymanski.github.io/interpreting-jstats-number-of-full-gc-events/" target="_blank" rel="noopener">https://kamilszymanski.github.io/interpreting-jstats-number-of-full-gc-events/</a><br><a href="http://blog.csdn.net/iter_zc/article/details/41825395" target="_blank" rel="noopener">http://blog.csdn.net/iter_zc/article/details/41825395</a><br><a href="http://www.iteye.com/topic/1119491" target="_blank" rel="noopener">http://www.iteye.com/topic/1119491</a>   </p>
<p><strong>CMS缺点</strong>:<br>CMS回收器采用的基础算法是Mark-Sweep。所有CMS不会整理、压缩堆空间。这样就会有一个问题：经过CMS收集的堆会产生空间碎片。CMS不对堆空间整理压缩节约了垃圾回收的停顿时间，但也带来的堆空间的浪费。为了解决堆空间浪费问题，CMS回收器不再采用简单的指针指向一块可用堆空间来为下次对象分配使用。而是把一些未分配的空间汇总成一个列表，当JVM分配对象空间的时候，会搜索这个列表找到足够大的空间来hold住这个对象。   </p>
<p>需要更多的CPU资源。从上面的图可以看到，为了让应用程序不停顿，CMS线程和应用程序线程并发执行，这样就需要有更多的CPU，单纯靠线程切 换是不靠谱的。并且，重新标记阶段，为空保证STW快速完成，也要用到更多的甚至所有的CPU资源。当然，多核多CPU也是未来的趋势！</p>
<p>CMS的另一个缺点是它需要更大的堆空间。因为CMS标记阶段应用程序的线程还是在执行的，那么就会有堆空间继续分配的情况，为了保证在CMS回 收完堆之前还有空间分配给正在运行的应用程序，必须预留一部分空间。也就是说，<strong>CMS不会在老年代满的时候才开始收集。相反，它会尝试更早的开始收集，已 避免上面提到的情况：在回收完成之前，堆没有足够空间分配！默认当老年代使用68%的时候，CMS就开始行动了。 – XX:CMSInitiatingOccupancyFraction =n 来设置这个阀值。但是如果在CMS运行期间，预留的内存无法满足程序需要时，则会出现concurrent mode fail之后会退化成Serial Old收集器，它是单线程的标记-压缩收集器，所以耗时会非常的长.</strong><br>总得来说，CMS回收器减少了回收的停顿时间，但是降低了堆空间的利用率。  </p>
<p>啥时候用CMS:如果你的应用程序对停顿比较敏感，并且在应用程序运行的时候可以提供更大的内存和更多的CPU(也就是硬件牛逼)，那么使用CMS来收集会给你带来好处。还有，如果在JVM中，有相对较多存活时间较长的对象(老年代比较大)会更适合使用CMS。   </p>
<p><strong>问题：minor GC是否也会导致STW呢? </strong><br><a href="https://www.zhihu.com/question/29114369?sort=created" target="_blank" rel="noopener">https://www.zhihu.com/question/29114369?sort=created</a><br><a href="https://blogs.oracle.com/jonthecollector/our-collectors" target="_blank" rel="noopener">https://blogs.oracle.com/jonthecollector/our-collectors</a><br><a href="https://www.zhihu.com/question/21535747/answer/144884632" target="_blank" rel="noopener">https://www.zhihu.com/question/21535747/answer/144884632</a><br>目前所有的新生代gc都是需要STW的，STW总会发生 不管是新生代还是老年代 就算是CMS也有STW的时候。重点是 时间长短<br>Serial：单线程STW，复制算法<br>ParNew：多线程并行STW，复制算法<br>Parallel Scavange：多线程并行STW，吞吐量优先，复制算法<br>G1：多线程并发，可以精确控制STW时间，整理算法<br>因为full gc耗时远高于minor gc，所以通常忽略minor gc几十毫秒的停顿。   </p>
<p><strong>GC收集器分类与常见组合</strong>：<br>按线程：<br>单线程：Serial、SerialOld<br>多线程：ParNew、Parallel Scavenge、Parallel Old、CMS、G1<br>按适用代：<br>新生代: Serial、ParNew、Parallel Scavenge<br>老年代: SerialOld、CMS 、Parallel Old<br>G1可以在新生代和老年代使用<br>常见的组合ParNew+CMS  ； Parallel Scavenge+Parallel Old    </p>
<p><strong>HotSpot JVM支持哪些垃圾收集器？</strong><br>Hotspot JVM实现包括了Serial GC, Parallel GC, CMS, G1 GC 4套算法组合。下面来讲一讲这些算法组合分别包括了哪些算法。   </p>
<ol>
<li>Serial GC算法：Serial Young GC ＋ Serial Old GC （实际上它是全局范围的Full GC），适用于小程序或低配置计算机系统；    </li>
<li>Parallel GC算法：（并行的）Parallel Young GC ＋ PS MarkSweep GC / （并行的）Parallel Old GC（全局范围的Full GC），选PS MarkSweep GC 还是 Parallel Old GC 由参数UseParallelOldGC来控制，适用于对吞吐量敏感的应用；   </li>
<li>CMS算法：（并行的）ParNew（Young）GC + （并发的）CMS（Old）GC （piggyback on ParNew的结果／老生代存活下来的object只做记录，不做compaction）＋ Full GC for CMS算法（应对核心的CMS GC某些时候的不赶趟，开销很大），适用于对延时敏感的应用；    </li>
<li>G1 GC：（并行的）Young GC ＋（并行的）mixed GC（新生代，再加上部分老生代）＋ Full GC for G1 GC算法（应对G1 GC算法某些时候的不赶趟，开销很大）。G1 GC中开销较大的object marking算法部分是跟applicaiton一起并发的，其开始到结束时间上甚至可以跨越好几次Young GC。适用于延时和吞吐量都有要求的应用，调教相对前述3中GC算法组合为烦。   </li>
<li>上述组合描述已特别指出并行（parallel）还是并发（concurrent）。Hotspot JVM语境下，这两个概念是严格区分的。并行是指STW（stop-the-world）状态下的GC算法或部分算法的多线程运行；并发是指非STW状态下GC算法或部分算法跟applicaiton一起分享多个线程来运行。<br>关于G1，可参考:<a href="http://www.importnew.com/15311.html" target="_blank" rel="noopener">http://www.importnew.com/15311.html</a>   <a href="http://blog.csdn.net/qq_34280276/article/details/52863551" target="_blank" rel="noopener">http://blog.csdn.net/qq_34280276/article/details/52863551</a>   <a href="https://blogs.oracle.com/jonthecollector/our-collectors" target="_blank" rel="noopener">https://blogs.oracle.com/jonthecollector/our-collectors</a>   <a href="http://ivywang.iteye.com/blog/2146645" target="_blank" rel="noopener">http://ivywang.iteye.com/blog/2146645</a></li>
</ol>
<p><img src="/data/upload/2a31f4f8-de13-11e7-99e4-d46a6ad5b910.png" alt="2a31f4f8-de13-11e7-99e4-d46a6ad5b910.png"></p>
<p>5、<strong>数据库查询</strong><br>许多请求响应速度慢的原因，最终都是由于糟糕的数据库查询语句所导致的。如何定位到这些糟糕的查询语句呢？MySQL提供慢查询日志的功能。能够记录下响应时间超过一定阀值(默认10秒)的SQL查询.<br>查看是否启用慢日志: show variables like ‘log_slow_queries’;   查看慢于多少秒的SQL会记录到慢日志中:show variables like ‘long_query_time’;<br>通过配置my.cnf，可以修改满日志的相关配置: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">port= 3306</span><br><span class="line"></span><br><span class="line">slow-query-log=ON # 慢查询：确认开启</span><br><span class="line">slow-query-log-file=&quot;/var/log/mysql/mysql-slow.log&quot; # 慢查询：日志文件及路径</span><br><span class="line">long_query_time = 1 # 慢查询：指定超过1s仍未完成的语句，为执行过慢的语句.默认是10s</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.执行一条慢查询SQL语句</span><br><span class="line">mysql&gt; select sleep(2);</span><br><span class="line">2.查看是否生成慢查询日志</span><br><span class="line">ls /usr/local/mysql/data/slow.log</span><br><span class="line">如果日志存在，MySQL开启慢查询设置成功！</span><br></pre></td></tr></table></figure>
<p>6、<strong>系统资源的使用</strong>：<br>查看CPU当前的利用率和系统的load，查看网卡的流量，查看磁盘IO的密集程度，查看内存的使用等。通过硬件指标来判断资源是否已经达到瓶颈。通过这些指标可以将应用分为CPU密集型、网络密集型、磁盘IO密集型、内存使用密集型等。根据应用的特征来进行机器配置的选型，以便使资源的利用达到最大化。   </p>
<h3 id="性能测试工具"><a href="#性能测试工具" class="headerlink" title="性能测试工具"></a>性能测试工具</h3><p>性能测试是指通过一些自动化的测试工具模拟多种正常、峰值，以及异常负载的条件来对系统的各项性能指标进行测试。在系统上线之前，需要经过一系列的性能测试，以确定系统在各种负载下的性能指标变化，发现系统潜在的一些瓶颈和问题。</p>
<p>1、<strong>ab</strong>-apache bench，内置于apache http server中。是一款专门用来对HTTP服务器进行性能测试的工具，可以模拟多个并发请求来对服务器进行压力测试，得出服务器在高负载下能够支持的qps及应用的响应时间。  </p>
<p>2、Apache <strong>JMeter</strong> ：功能比ab更强大。<br>在执行性能测试的同时，可以通过一些工具，如jsconsole,VisualVM,来远程实时查看测试机的负载，内存使用，GC等情况。<br>以Tomcat为例，配置JAVA_OPTS：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CATALINA_OPTS=&quot;$CATALINA_OPTS -Djava.rmi.server.hostname=172.16.18.155  -Dcom.sun.management.jmxremote  -Dcom.sun.management.jmxremote.port=18081 </span><br><span class="line"> -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false&quot;</span><br></pre></td></tr></table></figure>
<p>3、HP LoadRunner -商业性能测试工具  </p>
<p>4、<strong>反向代理引流</strong><br>在分布式环境下，流量真正到达服务器之前，一般会经过负载均衡设备进行转发，通过改变负载均衡的策略，可以改变后端服务器所承受的压力。在新版本发布之前，可以先对少部分机器进行灰度发布，以验证程序的正确性和稳定性，并且通过修改负载均衡策略，可以改变机器所承受的负载，达到对在线机器进行性能基准测试的目的。  </p>
<p>5、<strong>TCPCopy</strong><br>TCPCopy是网易开源的，它是一款请求复制工具，能够将在线请求复制到测试机器，模拟真实环境，达到程序在不上线的情况下承担线上真是流量的效果。<br>TCPCopy分为client与server，client运行在真实环境的线上服务器之上，用来捕获在线请求数据包，而server运行在测试机上，用来截获响应包，并将响应包的头部信息传递给client，已完成TCP交互。   </p>
<h3 id="性能优化措施"><a href="#性能优化措施" class="headerlink" title="性能优化措施"></a>性能优化措施</h3><p>通过上述方法找到性能瓶颈点之后，就需要对找到的性能瓶颈点进行优化。可以从多个方面入手，如:前端的资源文件，后端的Java程序，数据传输，结果缓存，数据库，JVM的GC，服务器硬件等。<br>1、<strong>前端性能优化</strong><br>指标：页面造成的HTTP请求数量，是否使用CDN网络，是否使用压缩。<br>2、<strong>Java程序优化</strong><br>单例模式，Future模式，线程池，服务端网络IO模型，减少线程上下文切换，降低锁竞争(使用原子变量，减小锁范围，将独占锁改为读写锁等)，压缩，结果缓存，数据库查询性能优化(合理使用索引，explain分析SQL，反范式设计如冗余存储以减少表关联带来的随机io和全表扫描，<br>MySQL使用查询缓存：<br>查看是否开启缓存:select @@query_cache_type;<br>查看缓存总大小：select @@query_cache_size;<br>查看记录集缓存限制:select @@query_cache_limit;   </p>
<p><strong>使用搜索引擎</strong>：在分库分表后，无法进行复杂的条件查询，这个时候就需要搜索引擎了。  </p>
<p><strong>使用key-value数据库</strong>:对于保有海量数据的互联网企业来说，多表的关联查询是非常忌讳的。SQL的功能被很大程度地弱化了。为了达到更大的并发，可以采用NoSQL数据库。   </p>
<p><strong>GC优化</strong>: JVM在进行垃圾回收时，会导致所有的工作线程暂停(stop the world),GC已成为影响Java应用性能的一个重要因素。<br>查看GC日志中的MinorGC、Full GC的频率，GC导致的停顿时间及GC发生的原因等。<br>需要注意一点的是:如果GC在PermGen上操作，而通常永久代存放的是已被虚拟机加载的类信息，及常量、静态变量、即使编辑器编译后的代码等数据，启动后一般非常稳定，GC回收的内存也十分有限。如果是因为PermGen空间不够而频繁发生FullGC，可能的情况是1，PermGen确实设置得过小，调整-XX:PermSize和-XX:MaxPermSize，2:可能是由于错误的代码导致频繁类加载，需要使用jmap将堆dump下来进行分析。  </p>
<p><strong>硬件提升性能</strong>:缓存服务器加大内存，磁盘IO密集的选用SSD，CPU密集的增加CPU核数，负载均衡节点注意网卡和带宽。   </p>
<h2 id="Java应用故障排查"><a href="#Java应用故障排查" class="headerlink" title="Java应用故障排查"></a>Java应用故障排查</h2><h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><p>在进行故障定位时，知识和经验是发现问题的基础，数据是依据，而工具则是运用知识的手段。知识和经验告诉我们怎么去做，而运用工具能帮助我们更加快速地发现和定位问题。<br><strong>1、jps   </strong><br>输出java进程id，并显示其主类。选项：</p>
<ul>
<li>-q 只输出进程id  </li>
<li>-m 输出传递给main函数的参数  </li>
<li>-l 输出主类全名，如果是jar，则输出jar文件路径  </li>
<li>-v 输出虚拟机进程启动时所带的JVM参数     </li>
</ul>
<p>2、<strong>jstat</strong><br>可参考<a href="http://blog.csdn.net/zhaozheng7758/article/details/8623549" target="_blank" rel="noopener">http://blog.csdn.net/zhaozheng7758/article/details/8623549</a><br>用来对虚拟机各种运行状态进行监控，如查看类加载与卸载情况，管理内存使用和垃圾收集等信息，监视JIT的运行情况等。几乎包括了JVM运行的方方面面。在无法使用图形化工具如jconsole,VisualVM时，jstat成为了运行期定位问题的首选。<br>jstat -options 可列出所有选项<br>常见的有</p>
<ul>
<li>-class (查看类加载器的统计信息) </li>
<li>-compiler (JIT信息) </li>
<li>-gc (查看JVM中垃圾收集情况的统计信息，包括Eden区，2个survivor区，老年代，永久代的容量和已用空间，GC时间等) </li>
<li>-gccapacity (各区大小) </li>
<li>-gccause (最近一次GC统计和原因) </li>
<li>-gcnew (新区统计)</li>
<li>-gcnewcapacity (新区大小)</li>
<li>-gcold (老区统计)</li>
<li>-gcoldcapacity (老区大小)</li>
<li>-gcpermcapacity (永久区大小)</li>
<li>-gcutil (GC统计汇总)</li>
<li>-printcompilation (HotSpot编译统计)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcutil &lt;pid&gt;:统计gc信息显示列名具体描述</span><br><span class="line">S0    年轻代中第一个survivor（幸存区）已使用的占当前容量百分比</span><br><span class="line">S1    年轻代中第二个survivor（幸存区）已使用的占当前容量百分比</span><br><span class="line">E     年轻代中Eden（伊甸园）已使用的占当前容量百分比</span><br><span class="line">O     old代已使用的占当前容量百分比</span><br><span class="line">P    perm代已使用的占当前容量百分比</span><br><span class="line">YGC    从应用程序启动到采样时年轻代中gc次数</span><br><span class="line">YGCT   从应用程序启动到采样时年轻代中gc所用时间(s)</span><br><span class="line">FGC   从应用程序启动到采样时old代(全gc)gc次数</span><br><span class="line">FGCT  从应用程序启动到采样时old代(全gc)gc所用时间(s)</span><br><span class="line">GCT   从应用程序启动到采样时gc用的总时间(s)</span><br></pre></td></tr></table></figure>
<p>3、<strong>jinfo</strong>  查看应用程度的配置参数，及打印运行JVM时所制定的JVM参数。比jsp -v能查看未被显式指定的JVM参数的系统默认值。<br>-sysprops选项将虚拟机进程中所指定的System.getProperties()的内容打印出来<br>-flags：查看vm参数 ,如果不指定，则同时包含-sysprops和flags的输出。<br>jinfo还能够在运行期间修改JVM参数，通过使用-flag name=value或者-flag [+|-]name来修改。   </p>
<p>4、<strong>jstack</strong><br>用来生成虚拟机当前的线程快照信息，线程快照就是当前虚拟机每一个线程正在执行的方法堆栈的集合。主要是为了定位线程长时间没有响应的原因，如线程死锁、网络请求没有设置超时时间而长时间没有返回、死循环、信号量没有释放等，都有可能导致线程长时间停顿。   </p>
<ul>
<li>-F当jstack [-l] pid’没有相应的时候强制打印栈信息</li>
<li>-l长列表. 打印关于锁的附加信息,例如属于java.util.concurrent的ownable synchronizers列表.</li>
<li>-m打印java和native c/c++框架的所有栈信息.</li>
<li>pid 需要被打印配置信息的java进程id,可以用jps查询.</li>
</ul>
<p>5、<strong>jmap</strong><br>可以输出所有内存中对象的工具。可以用来查看等待回收对象的队列，查看堆的概要信息(包括采用的是哪种GC收集器，堆使用情况，及通过JVM参数指定的各个内存空间的大小等)，甚至可以将VM 中的heap以二进制dump输出成文本，之后便可以通过图形化工具如MAT进行堆分析，内存中有哪些对象，分别占用的空间，以便找到诸如内存泄漏等问题的祸根。<br>需要注意的是，jmap执行堆dump操作时，由于生成的转储文件较大，将耗费大量的系统资源。因此，应避免在系统高位运行时执行该指令，否则有可能造成短时间内系统无法响应的情况。  </p>
<ul>
<li>-heap 打印heap的概要信息，包括使用的回收器类型、堆的配置信息、各内存分代的空间使用情况</li>
<li>-dump:[live,]format=b,file=<filename> 使用hprof二进制形式,输出jvm的heap内容到文件=. live子选项是可选的，假如指定live选项,那么只输出活的对象到文件. </filename></li>
<li>-finalizerinfo 打印正等候回收的对象的信息.</li>
<li>-histo[:live] 打印每个class的实例数目,内存占用,类全名信息. VM的内部类名字开头会加上前缀”*”. 如果live子参数加上后,只统计活的对象数量. </li>
<li>-permstat 打印classload和jvm heap永久层的信息. 包含每个classloader的名字,活泼性,地址,父classloader和加载的class数量. 另外,内部String的数量和占用内存数也会打印出来. </li>
<li>-F 当JVM对-dump操作没有响应时，强制生成转储快照。</li>
<li>-J 传递参数给jmap启动的jvm. </li>
</ul>
<p>6、<strong>BTrace</strong><br>可参考：<a href="http://mgoann.iteye.com/blog/1409667" target="_blank" rel="noopener">http://mgoann.iteye.com/blog/1409667</a>  <a href="http://www.jianshu.com/p/93e94b724476" target="_blank" rel="noopener">http://www.jianshu.com/p/93e94b724476</a><br>BTrace是一个开源的Java程序动态跟踪工具，前面已介绍过如何使用它来监控方法的执行时间。它的基本工作原理是通过Hotsopt虚拟机的HotSwap技术将跟踪的代码动态替换到被跟踪的Java程序内，以观察程序运行的细节(BTrace 主要使用了 Instrumentation + ASM技术来实现对正在运行进程的探测。)。如打印方法的参数，变量的值及返回值等。通过使用BTrace，可以在不修改代码、不重启应用的情况下，动态地查看程序运行的细节，方便地对程序进行调试。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">原方法：</span><br><span class="line"><span class="function">priavte <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> com.sun.btrace.annotations.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.sun.btrace.BTraceUtils.*;</span><br><span class="line"></span><br><span class="line">btrace脚本：</span><br><span class="line"><span class="meta">@BTrace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodTimeCost</span></span>&#123;</span><br><span class="line">    <span class="meta">@TLS</span> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> starttime;</span><br><span class="line">    <span class="meta">@OnMethod</span>(clazz=<span class="string">"net.xby1993.test.Main"</span>, method=<span class="string">"sub"</span>,location=<span class="meta">@Location</span>(Kind.ENTRY))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startExecute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        starttime=timeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@OnMethod</span>(clazz=<span class="string">"net.xby1993.test.Main"</span>, method=<span class="string">"sub"</span>,location=<span class="meta">@Location</span>(Kind.RETURN))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">endExecute</span><span class="params">(@Return <span class="keyword">int</span> rtn,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timecost=timeMillis()-starttime;</span><br><span class="line">        println(strcat(<span class="string">"a:"</span>,str(a)));</span><br><span class="line">        println(strcat(<span class="string">"b:"</span>,str(b)));</span><br><span class="line">        println(strcat(<span class="string">"return:"</span>,str(rtn)));</span><br><span class="line">        println(strcat(<span class="string">"costtime:"</span>,str(timecost)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">btrace &lt; pid &gt; &lt; btrace-script &gt;</span><br><span class="line">btrace 3050 MethodTimeCost.java</span><br></pre></td></tr></table></figure>
<p>值得注意的是，@TLS声明的变量是 ThreadLocal的， 每个线程都会有一份这个自己的startTime 变量。</p>
<p>btrace还提供了一个vaisualvm上的一个插件，可以执行btrace脚本。尝试了下，可以attach到本机的jvm进程上，但是远程主机的JVM进程不行。有的说通过端口转发绑定的方式可以，但是还是没有试出来。<br>运行jvisualvm.exe, 选择工具-&gt;插件-&gt;可用插件 选择 BTrace Workbench进行在线安装。  选择需要监控的进程,右击 trace application,在btrace的工作台中直接编写脚本并执行,执行后，当被监控的程序运行了这些检查点的方法时，btrace会在控制台对执行时间进行输出。</p>
<p>注解说明：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">@BTrace</span><br><span class="line">声明这个类是个BTrace脚本.unsafe参数表示是否不安全的模式执行.</span><br><span class="line"></span><br><span class="line">方法annotation</span><br><span class="line">@OnMethod: 声明 探查点（probe point）</span><br><span class="line">clazz: 全路径类名，支持正则表达式，格式为/正则表达式/</span><br><span class="line">+类名 匹配子类</span><br><span class="line">@前缀 匹配anotation声明的类</span><br><span class="line">method: 方法名，支持正则表达式，格式为/正则表达式/， anotation使用@</span><br><span class="line">location: 用@Location来表明在什么时候时候去执行脚本</span><br><span class="line">Kind.ENTRY 进入方法时</span><br><span class="line">Kind.RETURN 方法返回时</span><br><span class="line">Kind.THROW 抛出异常时</span><br><span class="line">Kind.ARRAY_SET 设置数组元素时</span><br><span class="line">Kind.ARRAY_GET 获取数组元素时</span><br><span class="line">Kind.NEWARRAY 创建新数组时</span><br><span class="line">Kind.NEW 创建新对象时</span><br><span class="line">Kind.CALL 调用方法时</span><br><span class="line">Kind.CATCH 捕获异常时</span><br><span class="line">Kind.FIELD_SET 获取对象属性时</span><br><span class="line">Kind.FIELD_SET 设置对象属性时</span><br><span class="line">Kind.ERROR 方法由于发生未被捕获的异常结束时</span><br><span class="line">Kind.SYNC_ENTRY 进入同步块时</span><br><span class="line">Kind.SYNC_EXIT 离开同步块时</span><br><span class="line">type 方法类型， 不含方法名、参数民、异常声明。</span><br><span class="line">@OnTimer 定时器，间隔出发动作。</span><br><span class="line">参数： 间隔时间，单位毫秒</span><br><span class="line">@OnError BTrace代码发生异常时回调</span><br><span class="line">@OnExit BTrace代码调用exit来结束探测时回调该注释的方法</span><br><span class="line">@OnEvent 接受客户端事件时会回调。目前，当客户端命令上执行Ctrl-C (SIGINT)时会发送一个时间到服务器端，从而触发@OnEvent注释的方法。</span><br><span class="line">@OnLowMemory 内存低于设置的阈值时回调方法</span><br><span class="line">pool 内存池名称</span><br><span class="line">threshold 阈值大小</span><br><span class="line">@OnProbe 支持使用xml格式来声明探测点点和探测动作。</span><br><span class="line"></span><br><span class="line">未声明注解的方法参数</span><br><span class="line">未声明注解的方法参数的映射，根据探测点类型locaiton的不同而不同：</span><br><span class="line">Kind.ENTRY 方法参数</span><br><span class="line">Kind.RETURN 方法返回值</span><br><span class="line">Kind.THROW 被抛出的异常</span><br><span class="line">Kind.ARRAY_SET 数值下标</span><br><span class="line">Kind.ARRAY_GET 数组下标</span><br><span class="line">Kind.CATCH 被捕获的异常</span><br><span class="line">Kind.FIELD_SET 被设置属性的值</span><br><span class="line">Kind.NEW 创建的对象的类型</span><br><span class="line">Kind.ERROR 被抛出的异常</span><br><span class="line"></span><br><span class="line">字段注解</span><br><span class="line">Export 将字段保罗给jstat访问</span><br><span class="line">Property 将字段暴露注册为MBean 属性，可以通过JMX进行查看</span><br><span class="line">TLS 将字段声明为TheadLocal字段，每个线程拥有自己独立的字段</span><br><span class="line"></span><br><span class="line">参数annotation介绍</span><br><span class="line">@Self 声明探测的当前对象this</span><br><span class="line">@Return 方法返回对象</span><br><span class="line">@ProbeClassName 当前探测点所在的类名</span><br><span class="line">@ProbeMethodName 当前探测点所在的方法名</span><br><span class="line">fqn 是否获取全路径方法名称fully qualified name (FQN)</span><br><span class="line">@Duration 执行时间，单位纳秒，一般同 Kind.RETURN 和 Kind.ERROR 配合使用</span><br><span class="line">@TargetInstance 配合 Kind.CALL使用，声明了被调用方法所在的对象</span><br><span class="line">@TargetMethodOrField Kind.CALL使用，声明了被调用方法所在的对象的方法</span><br></pre></td></tr></table></figure>
<p>7、<strong>JConsole</strong><br>可参考 <a href="http://jiajun.iteye.com/blog/810150" target="_blank" rel="noopener">http://jiajun.iteye.com/blog/810150</a><br>不过目前推荐使用JVisualVM来替代JConsole   </p>
<p>8、<strong>JVisualVM</strong><br>可参考：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/</a>  <a href="http://blog.csdn.net/a19881029/article/details/8432368" target="_blank" rel="noopener">http://blog.csdn.net/a19881029/article/details/8432368</a><br>连接：<br>1、本地机器的程序直接可以监听到<br>2、远程机器的程序需要加上JVM参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Dcom.sun.management.jmxremote= true</span><br><span class="line">-Dcom.sun.management.jmxremote.port= 9090</span><br><span class="line">-Dcom.sun.management.jmxremote.ssl= false</span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate= false</span><br></pre></td></tr></table></figure></p>
<p>VisualVM是一款”All-in-One”工具，涵盖了JVM内存监视，性能分析，线程，及堆转储分析、垃圾回收监视等几乎所有功能。<br>常用功能:内存监控，GC监控，应用程序分析，线程分析，堆dump分析，CPU及内存抽样、BTrace跟踪等。   </p>
<p>Java VisualVM 插件地址：打开Java VisualVM检查更新插件时，默认的连接连不上，通过浏览器访问之后发现默认的服务器已经404，新地址已经迁移到github，下面这个地址里面有不同版本jdk对应的插件中心地址：<a href="https://visualvm.github.io/pluginscenters.html" target="_blank" rel="noopener">https://visualvm.github.io/pluginscenters.html</a></p>
<p>9、<strong>MAT</strong>(Memory Analyzer Tool)<br>可参考：<a href="http://flychao88.iteye.com/blog/2192266" target="_blank" rel="noopener">http://flychao88.iteye.com/blog/2192266</a>  <a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-ecl-ma/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/os-cn-ecl-ma/</a><br>一个基于Eclipse的内存分析工具，是一个快速、功能丰富的JAVA heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。使用内存分析工具从众多的对象中进行分析，快速的计算出在内存中对象的占用大小，看看是谁阻止了垃圾收集器的回收工作，并可以通过报表直观的查看到可能造成这种结果的对象。<br>巧妇难为无米之炊，我们首先需要获得一个堆转储文件。只要你设置了如下所示的 JVM 参数：-XX:+HeapDumpOnOutOfMemoryError  JVM 就会在发生内存泄露时抓拍下当时的内存状态，也就是我们想要的堆转储文件。除此之外，还有很多的工具，例如 JMap，JConsole 都可以帮助我们得到一个堆转储文件。   </p>
<h3 id="典型案例分析"><a href="#典型案例分析" class="headerlink" title="典型案例分析"></a>典型案例分析</h3><p>1、<strong>内存溢出OutOfMemory</strong><br>测试:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOOM</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Obj</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">byte</span>[] bytes=<span class="string">"hello world"</span>.getBytes();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Obj&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Obj());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了尽快出现问题，这里限制堆内存的大小，并在发生OOM时，dump堆。使用的JVM参数如下:<br>-Xms10m -Xmx10m -Xmn5m -XX:+HeapDumpOnOutOfMemoryError   </p>
<p>2、<strong>线程死锁或信号量没有释放</strong><br>当线程因为资源争用而发生死锁，或者因为使用了信号量而没有及时释放，在测试环境下很难发现该问题，特别是没有进行压力测试就上线的情况下，即便是上线，应用访问量不高，短时间内可能故障也不会发作。<br>这些会导致线程资源耗光(如果采用线程池，此时并不会出现OOM异常，而是表现为请求长时间没有响应，应用僵死)。但是对应的JVM进程却是活跃的，并且此时的系统资源消耗，如CPU的load往往非常低。 这时需要线程dump进行分析。   </p>
<p>3、<strong>类加载冲突</strong><br>有时候，当使用相同代码的应用发布上线以后，在分布式环境下，会发现一部分机器运行正常，而另一部分机器则会抛出NoClassDefFoundError、NoSuchMethodError这样的异常，这是为何？<br>在一个大型的企业级应用中，可能会依赖很多jar包，而这些jar可能又会依赖其他的jar，最终会导致依赖关系变得错综复杂。有时候，可能会出现依赖一个jar的多个版本，更有甚者，某些jar会直接将依赖的jar也打包进去，这样就使得<strong>很多class签名相同的类同时存在</strong>。<br>在不同的机器上，对不同jar中同名类的加载有时候并不完全一致。所以才会导致这些问题。那为什么测试时没有问题，因为由于在相同机器上，无论启动多少次，类得加载顺序基本不变。<br>通过在JVM启动时加上<code>-verbose:class</code>,可以查到具体的class究竟是从哪个jar文件中加载进来的。    </p>

      
    </div>
    
    
    
    

 
    

    

    
      <div>
       <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    xbynet
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://xbynet.top/2017/12/17/读书笔记-chapter4-系统稳定性-大型网站分布式架构与设计实践/" title="[读书笔记]chapter4-系统稳定性-大型网站分布式架构与设计实践">http://xbynet.top/2017/12/17/读书笔记-chapter4-系统稳定性-大型网站分布式架构与设计实践/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>
  
      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/MicroService/" rel="tag"><i class="fa fa-tag"></i> MicroService</a>
          
            <a href="/tags/msa/" rel="tag"><i class="fa fa-tag"></i> msa</a>
          
            <a href="/tags/架构/" rel="tag"><i class="fa fa-tag"></i> 架构</a>
          
            <a href="/tags/soa/" rel="tag"><i class="fa fa-tag"></i> soa</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/17/读书笔记-chapter3-互联网安全架构-大型网站分布式架构与设计实践/" rel="next" title="[读书笔记]chapter3-互联网安全架构-大型网站分布式架构与设计实践">
                <i class="fa fa-chevron-left"></i> [读书笔记]chapter3-互联网安全架构-大型网站分布式架构与设计实践
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/12/17/Consistent-Hash一致性哈希算法/" rel="prev" title="Consistent-Hash一致性哈希算法">
                Consistent-Hash一致性哈希算法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMjQ3OS85MDQw"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://sfault-avatar.b0.upaiyun.com/206/579/2065794108-5721d3ee75b36_huge256"
                alt="xbynet" />
            
              <p class="site-author-name" itemprop="name">xbynet</p>
              <p class="site-description motion-element" itemprop="description">青苔边，折梅不赏;古道旁，煮酒不饮。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/xbynet" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:xbynet@outlook.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          

          <div id="aplayer1" class="aplayer"></div>
<script src="/asserts/js/APlayer.min.js"></script>
<script>
    var musiclist=[
        {title:'素雨',author:'孙雪宁',url:'http://ws.stream.qqmusic.qq.com/C1000040LV2h3FzIVl.m4a?fromtag=38',pic:'https://y.gtimg.cn/music/photo_new/T002R300x300M000003mxnKZ0WbTPc.jpg?max_age=2592000'},
        {title:'爱在上',author:'崔子格',url:'http://dl.stream.qqmusic.qq.com/M8000019Hx0J3tqcaV.mp3?vkey=93EB395793C648848684E76AE3B2D6E08F9EC8C7412B177750792C7CEC73BDC4FD06C1F78C02D9186339549C042F2CA5955914BA8322F6E4&guid=5150825362&fromtag=1',pic:'https://y.gtimg.cn/music/photo_new/T002R300x300M000003ksYhQ1EmEcr.jpg?max_age=2592000'}
    ]
    var tmpindex=Math.floor(Math.random()*musiclist.length);
    var music=musiclist[tmpindex];
    var ap = new APlayer({
        element: document.getElementById('aplayer1'),
        narrow: false,
        autoplay: false,
        showlrc: false,
        mutex: true,
        theme: '#e6d0b2',
        preload: 'metadata',
        mode: 'circulation',
        music: {
            title: music.title,
            author: music.author,
            url: music.url,
            pic: music.pic
        }
    });
</script>

<!-- 
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=28815250&auto=0&height=66"></iframe>
-->
        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#在线日志分析"><span class="nav-number">1.</span> <span class="nav-text"><a href="#&#x5728;&#x7EBF;&#x65E5;&#x5FD7;&#x5206;&#x6790;" class="headerlink" title="&#x5728;&#x7EBF;&#x65E5;&#x5FD7;&#x5206;&#x6790;"></a>&#x5728;&#x7EBF;&#x65E5;&#x5FD7;&#x5206;&#x6790;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集群监控"><span class="nav-number">2.</span> <span class="nav-text"><a href="#&#x96C6;&#x7FA4;&#x76D1;&#x63A7;" class="headerlink" title="&#x96C6;&#x7FA4;&#x76D1;&#x63A7;"></a>&#x96C6;&#x7FA4;&#x76D1;&#x63A7;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流量控制"><span class="nav-number">3.</span> <span class="nav-text"><a href="#&#x6D41;&#x91CF;&#x63A7;&#x5236;" class="headerlink" title="&#x6D41;&#x91CF;&#x63A7;&#x5236;"></a>&#x6D41;&#x91CF;&#x63A7;&#x5236;</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#高并发系统设计"><span class="nav-number">3.1.</span> <span class="nav-text"><a href="#&#x9AD8;&#x5E76;&#x53D1;&#x7CFB;&#x7EDF;&#x8BBE;&#x8BA1;" class="headerlink" title="&#x9AD8;&#x5E76;&#x53D1;&#x7CFB;&#x7EDF;&#x8BBE;&#x8BA1;"></a>&#x9AD8;&#x5E76;&#x53D1;&#x7CFB;&#x7EDF;&#x8BBE;&#x8BA1;</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#性能优化"><span class="nav-number">4.</span> <span class="nav-text"><a href="#&#x6027;&#x80FD;&#x4F18;&#x5316;" class="headerlink" title="&#x6027;&#x80FD;&#x4F18;&#x5316;"></a>&#x6027;&#x80FD;&#x4F18;&#x5316;</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何找到性能瓶颈"><span class="nav-number">4.1.</span> <span class="nav-text"><a href="#&#x5982;&#x4F55;&#x627E;&#x5230;&#x6027;&#x80FD;&#x74F6;&#x9888;" class="headerlink" title="&#x5982;&#x4F55;&#x627E;&#x5230;&#x6027;&#x80FD;&#x74F6;&#x9888;"></a>&#x5982;&#x4F55;&#x627E;&#x5230;&#x6027;&#x80FD;&#x74F6;&#x9888;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#性能测试工具"><span class="nav-number">4.2.</span> <span class="nav-text"><a href="#&#x6027;&#x80FD;&#x6D4B;&#x8BD5;&#x5DE5;&#x5177;" class="headerlink" title="&#x6027;&#x80FD;&#x6D4B;&#x8BD5;&#x5DE5;&#x5177;"></a>&#x6027;&#x80FD;&#x6D4B;&#x8BD5;&#x5DE5;&#x5177;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#性能优化措施"><span class="nav-number">4.3.</span> <span class="nav-text"><a href="#&#x6027;&#x80FD;&#x4F18;&#x5316;&#x63AA;&#x65BD;" class="headerlink" title="&#x6027;&#x80FD;&#x4F18;&#x5316;&#x63AA;&#x65BD;"></a>&#x6027;&#x80FD;&#x4F18;&#x5316;&#x63AA;&#x65BD;</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java应用故障排查"><span class="nav-number">5.</span> <span class="nav-text"><a href="#Java&#x5E94;&#x7528;&#x6545;&#x969C;&#x6392;&#x67E5;" class="headerlink" title="Java&#x5E94;&#x7528;&#x6545;&#x969C;&#x6392;&#x67E5;"></a>Java&#x5E94;&#x7528;&#x6545;&#x969C;&#x6392;&#x67E5;</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常用工具"><span class="nav-number">5.1.</span> <span class="nav-text"><a href="#&#x5E38;&#x7528;&#x5DE5;&#x5177;" class="headerlink" title="&#x5E38;&#x7528;&#x5DE5;&#x5177;"></a>&#x5E38;&#x7528;&#x5DE5;&#x5177;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#典型案例分析"><span class="nav-number">5.2.</span> <span class="nav-text"><a href="#&#x5178;&#x578B;&#x6848;&#x4F8B;&#x5206;&#x6790;" class="headerlink" title="&#x5178;&#x578B;&#x6848;&#x4F8B;&#x5206;&#x6790;"></a>&#x5178;&#x578B;&#x6848;&#x4F8B;&#x5206;&#x6790;</span></a></li></ol></li></ol></div>
            
          </div>
          
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xbynet</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">145.4k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  




  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("sHIc70OVniNsR5OI1atIhMuk-gzGzoHsz", "wt266j1nbmoGAFrXdwXt7TeS");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.3"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.3"></script>


  


  <a href="https://github.com/xbynet"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/567c3a48d796e2fc06ea80409cc9dd82bf714434/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_darkblue_121621.png"></a>

<script>

$(document).ready(function() {
//修复toc无法点击的问题
    $(".nav-item .nav-link").each(function(i){
              $(this).text($(this).attr("href").replace('#',''));
              $(this).parent().contents().filter(function() {
                  return this.nodeType == 3; //Node.TEXT_NODE
              }).remove();
            });
//主页阴影
      if(false){
            $('.post').addClass('post-index');
        }
    });
</script>
  
</body>
</html>
